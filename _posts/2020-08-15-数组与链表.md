---
layout: post
author: eature
published: true
categories: 数据结构与算法
tags:
- 算法
- 数据结构
---


#### 数组的定义
数组是一个线性表数据结构， 用一块连续的内存空间来存储相同的数据类型数据，数组最大的优势是支持就是支持数组内数据的随机访问， 时间复杂度的O(1)

#### 链表的定义
链表的是一组非连续的内存空间， 使用指针串起来， 形成的一组链式数据结构。链表有单链表、双链表、循环链表等数据结构， 链表与数组最本质的区别在于内存空间是否是连续。

#### 链表与数组的元素操作比较
* 元素的插入  
** 数组的元素插入的最好时间复杂度是插入位置刚好是在最后面， 时间复杂度是O(1)， 最坏时间复杂度是在第一位， 需要进行数据的搬移， 时间复杂度是在O(n)， 因为插入到每个位置的几率的相同的， 所以平均时间复杂度是O(n)
** 链表的元素插入只需要操作对应的指针的指向即可， 所以插入的时间复杂度是O(n), 但是链表这种数据结构并不支持数据的随机访问， 所以查找到对应位置的指针的时间复杂度是O(n)

* 元素的删除  
元素的删除与元素的插入类似， 数组的最好情况依然是删除最后一个的时候， 这样的话不需要做数据搬移，时间复杂度是O(1), 在其他情况上因为要保证数组内存空间的连续性， 删除元素以后会有空洞， 需要做数据搬移， 时间复杂度是O(n), 链表也与插入相同， 删除只需要修改对应的指针指向， 但查找需要花费O(n)的时间复杂度

* 元素的查找  
数组元素支持随机访问， 时间复杂度是O(1), 但这并不表示数组数据的查找的时间复杂度是O(1), 数组中查找数据需要花费O（n）的时间， 在有序的数组中使用二分查找， 时间复杂度则会降到O（logn）。
链表的数据查询需要从第一个元素遍历链表， 所以时间复杂度是O（n）， 因为链表并不支持随机访问， 所以即使是有序的链表， 也不能使用二分查找进行元素查询


#### 使用链表或者数组实现LRU缓存淘汰算法  
* 数组  
在数组头部或者尾部存储最近使用的数据， 如果数据只有没有使用过的话， 则直接插入数组头部或者尾部， 对应的时间复杂度是O（n）和O（n），相应的当需要淘汰缓存时则删除相应的数组尾部或者头部的数据， 对应的时间复复杂度是O（1）和O（n）, 所以整个的数据插入和删除的时间复杂度是O（n）， 之间因为需要进行数据的查找是否存在并进行数据搬移， 查找的时间复杂度度是O（n）， 搬移的时间复杂度是O（n）， 所以最终的时间复杂度是O（n） + O（n） + O（n），为O（3n） = O（n）

* 链表  
将最新使用过的数据存储在链表头部， 实现查找是否存在并插入的时间复杂度是O（n）， 删除对应的淘汰数据的时间复杂度， 如果是单向链表则是是O（n）， 双向链表的话则可以为O（1）， 所以总的时间复杂度是O（n）

